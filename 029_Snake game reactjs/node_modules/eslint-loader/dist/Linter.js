"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _process = _interopRequireDefault(require("process"));

var _path = require("path");

var _fsExtra = require("fs-extra");

var _loaderUtils = require("loader-utils");

var _ESLintError = _interopRequireDefault(require("./ESLintError"));

var _createEngine = _interopRequireDefault(require("./createEngine"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Linter {
  constructor(loaderContext, options) {
    this.loaderContext = loaderContext;
    this.options = options;
    this.resourcePath = this.parseResourcePath();
    const {
      CLIEngine,
      engine
    } = (0, _createEngine.default)(options);
    this.CLIEngine = CLIEngine;
    this.engine = engine;
  }

  parseResourcePath() {
    const cwd = _process.default.cwd();

    let {
      resourcePath
    } = this.loaderContext; // remove cwd from resource path in case webpack has been started from project
    // root, to allow having relative paths in .eslintignore
    // istanbul ignore next

    if (resourcePath.indexOf(cwd) === 0) {
      resourcePath = resourcePath.substr(cwd.length + (cwd === '/' ? 0 : 1));
    }

    return resourcePath;
  }

  lint(content) {
    try {
      return this.engine.executeOnText(content, this.resourcePath, true);
    } catch (_) {
      this.getEmitter(false)(_);
      return {
        src: content
      };
    }
  }

  printOutput(data) {
    const {
      options
    } = this; // skip ignored file warning

    if (this.constructor.skipIgnoredFileWarning(data)) {
      return;
    } // quiet filter done now
    // eslint allow rules to be specified in the input between comments
    // so we can found warnings defined in the input itself


    const res = this.filter(data); // if enabled, use eslint auto-fixing where possi